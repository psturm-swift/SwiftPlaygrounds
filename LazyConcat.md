# Concatenating sequences lazily
In chapter [UnfoldSequences.md][1] I described how you can create lazy sequences by `UnfoldSequence`. Sequences were generated by functions which returned the sequence values and had a mutable state.
In this chapter I want to show how `UnfoldSequence` can be used to concat two sequences lazily.

## Concat Operation
The concatenation of two sequences S and T is only possible if their elements are of the same type. The signature of the `concat` function looks therefore like this:

```Swift
func concat<S: Sequence, T: Sequence where
            S.Iterator.Element==T.Iterator.Element>(_ lhs: S, _ rhs: T) -> Result
``` 

The function concats two sequences `lhs` and `rhs`. Both can be of different sequence type but they contain elements of the same type. The concatenation can be defined by using the  `UnfoldSequence`. The state of the next-function will be a pair of Iterators. One iterator is iterating over `lhs` and the other one is iterating over  `rhs`.

The next-function can be defined as follows:

```Swift
func nextElement(state: inout (S.Iterator, T.iterator)) -> Element? {
    return state.0.next() ?? state.1.next()
}
```

As a reminder `state.0.next() ?? state.1.next()` is a short-form of the following piece of code:

```Swift
if let next = state.0.next() {
    return next
}
else {
    return state.1.next()
}
```

With each call this function increments the iterator of the first sequence until the sequence ends. Then it iterates over the second sequence.

In total the concat function looks like this:

```Swift
func concat<
        S: Sequence, T: Sequence where 
        S.Iterator.Element==T.Iterator.Element>(_ lhs: S, _ rhs: T)
        -> UnfoldSequence<S.Iterator.Element, (S.Iterator, T.Iterator)>
{
    typealias Element = S.Iterator.Element
    let nextElement = {
        (state: inout (S.Iterator, T.Iterator)) -> Element? in
        return state.0.next() ?? state.1.next()
    }
    return sequence(state: (lhs.makeIterator(), rhs.makeIterator()), next: nextElement)
}
```

## Fibonacci
In last chapter I wrote that the Fibonacci sequence could be two number longer for int. This is due to the fact that the sequence end was signaled a bit to early. With concat this can be changed easily.

I changed the `nextFibonacciNumber` a bit. It now returns sum instead of state.0.

```Swift
func fibonacci() -> UnfoldSequence<Int, (Int, Int)>
{
        let nextFibonacciNumber = {
            (state: inout (Int, Int)) -> Int? in

            let (sum, overflow) = Int.addWithOverflow(state.0, state.1)
            guard !overflow else { return nil }
            state = (state.1, sum)

            return sum
        }

        return sequence(state: (0, 1), next: nextFibonacciNumber)
}
```

If you print the sequence, it does not start with `0,1,1,2,...`. The first two elements are missing `1,2,3,5,...`. However, these two missing numbers can be easily added with `concat`:

```Swift
concat([0, 1], sequence(state: (0, 1), next: nextFibonacciNumber))
```

Now the sequence has 93 elements. So two more elements than before. And the `nextFibonacciNumber` function is still as simple as possible. There was no need to make it more difficult. Here is the code for the fibonacci sequence in total:

```Swift
func fibonacci() -> UnfoldSequence<Int, (Array<Int>.Iterator, UnfoldSequence<Int, (Int, Int)>.Iterator)>
{
        let nextFibonacciNumber = {
            (state: inout (Int, Int)) -> Int? in

            let (sum, overflow) = Int.addWithOverflow(state.0, state.1)
            guard !overflow else { return nil }
            state = (state.1, sum)

            return sum
        }

        concat([0, 1], sequence(state: (0, 1), next: nextFibonacciNumber))
}
```

[1]:	UnfoldSequences.md "UnfoldSequences.md"